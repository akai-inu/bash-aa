// Generated by CoffeeScript 1.9.3
var COLOR_1, COLOR_16, COLOR_256, argv, assignColorId, async, checkArgs, colorCalculator, colorType, convertRawToPixelList, fs, getArgs, getColorData, jpeg, pixelsToString, targetFile;

fs = require('fs');

async = require('async');

jpeg = require('jpeg-js');

argv = require('argv');

colorCalculator = require(__dirname + '/color-calculator');

COLOR_1 = '1';

COLOR_16 = '16';

COLOR_256 = '256';

getArgs = function() {
  var argOptions;
  argOptions = [
    {
      name: 'color256',
      type: 'boolean',
      description: 'convert to 256 colors (default)'
    }, {
      name: 'color16',
      type: 'boolean',
      description: 'convert to 16 colors (WIP)'
    }, {
      name: 'color1',
      type: 'boolean',
      description: 'convert to 1 color (WIP)'
    }
  ];
  return argv.option(argOptions).run();
};

checkArgs = function(args) {
  var getColorType, getTargetFile;
  getColorType = function() {
    var ref;
    if (args.options.color1 != null) {
      throw 'currently convert to 1 color is WIP.';
    } else if (((ref = args.options) != null ? ref.color16 : void 0) != null) {
      return 'currently convert to 16 colors is WIP.';
    }
    return COLOR_256;
  };
  getTargetFile = function() {
    if (args.targets.length === 0) {
      throw 'unknown target jpeg file';
    }
    return args.targets[0];
  };
  return [getColorType(), getTargetFile()];
};

getColorData = function(colorType) {
  return require(process.cwd() + '/color-data256.json');
};

convertRawToPixelList = function(imageData, callback) {
  return async.times(imageData.height / 2, function(y, nextY) {
    return async.times(imageData.width, function(x, nextX) {
      var b, g, index, pixel, r;
      index = imageData.width * y * 2 * 4 + x * 4;
      r = parseInt(imageData.data[index]);
      g = parseInt(imageData.data[index + 1]);
      b = parseInt(imageData.data[index + 2]);
      pixel = {
        r: r,
        g: g,
        b: b,
        x: x,
        y: y
      };
      return nextX(null, pixel);
    }, nextY);
  }, callback);
};

assignColorId = function(pixelRows, callback) {
  return async.map(pixelRows, function(row, nextY) {
    return async.map(row, function(pixel, nextX) {
      return colorCalculator.calc(pixel, (function(_this) {
        return function(err, result) {
          pixel.id = result.id;
          pixel.color = result.color;
          return nextX(null, pixel);
        };
      })(this));
    }, nextY);
  }, callback);
};

pixelsToString = function(pixelRows, callback) {
  return async.map(pixelRows, function(row, nextY) {
    return async.map(row, function(pixel, nextX) {
      return nextX(null, "\x1b[38;5;" + pixel.id + "m\x1b[48;5;" + pixel.id + "m.");
    }, function(err, pixelStrings) {
      return nextY(err, "echo -e '" + (pixelStrings.join('')) + "\x1b[0m'\n");
    });
  }, function(err, rowStrings) {
    return callback(err, rowStrings.join(''));
  });
};

colorType = null;

targetFile = null;

async.waterfall([
  function(next) {
    var args, ref;
    args = getArgs();
    ref = checkArgs(args), colorType = ref[0], targetFile = ref[1];
    return fs.readFile(targetFile, next);
  }, function(data, next) {
    var error, height, imageData, raw, ref, width;
    try {
      imageData = jpeg.decode(data);
    } catch (_error) {
      error = _error;
      return next(error, null);
    }
    ref = [imageData.width, imageData.height, imageData.data], width = ref[0], height = ref[1], raw = ref[2];
    if (width > 240 || height > 50) {
      return next('The image is too large.', null);
    }
    return convertRawToPixelList(imageData, next);
  }, function(pixelRows, next) {
    var colorData;
    colorData = getColorData(colorType);
    colorCalculator.init(colorData);
    return assignColorId(pixelRows, next);
  }, function(pixelRows, next) {
    return pixelsToString(pixelRows, next);
  }, function(strings, next) {
    return fs.writeFile(__dirname + '/output.sh', '#!/bin/bash\n\n' + strings, next);
  }
], function(err, result) {
  if (err != null) {
    throw err;
  }
  return console.log('Completed.');
});
